## 为什么需要缓存？

因为我们从磁盘中读取文件的速度相较于读取内存中的数据的速度是比较慢的，因此我们将常用的数据存入内存中（我们称之为缓存），以此来加快数据的读取速度。

## 为什么要淘汰缓存

这个很简单，就是因为我们现在服务器内存有限，不可能不断的将数据存入内存中而不淘汰。况且Java应用会有GC问题，过多的使用内存会造成频繁的FullGC，从而导致应用停顿。我们要做到就是通过淘汰算法让存入内存中的数据能发挥最大价值。

## 常用算法

### FIFO（先进先出）

先进先出算法，很容易理解，核心原则是：先进行缓存的数据先淘汰掉。

实现方式：使用队列来完成。

| 维度     | 程度                   |
| -------- | ---------------------- |
| 命中率   | 低                     |
| 复杂度   | 简单                   |
| 存储成本 | 低                     |
| 缺陷     | 速度快，但使用价值不高 |

### LRU（最近最少使用）

最近最少使用可以理解为:最近一段时间最少被访问的数据淘汰掉。

实现方式：一般使用链表完成。

| 维度     | 程度                                                 |
| -------- | ---------------------------------------------------- |
| 命中率   | 较高                                                 |
| 复杂度   | 较简单                                               |
| 存储成本 | 一般                                                 |
| 缺陷     | 速度较慢，需要遍历链表；仅从时间上考虑，没有考虑频率 |

### LFU（最不经常使用）

最不经常使用：基于最近访问频率来进行淘汰。

实现方式：一般使用Map完成。


| 维度     | 程度                                 |
| -------- | ------------------------------------ |
| 命中率   | 比LRU较高                            |
| 复杂度   | 较高                                 |
| 存储成本 | 需要维护所有的访问记录的频率数据结构 |
| 缺陷     | 仅考虑频率                           |